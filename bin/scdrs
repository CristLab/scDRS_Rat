#!/usr/bin/env python

import fire
import pandas as pd
import numpy as np
from statsmodels.stats.multitest import multipletests
import scdrs
from typing import Dict, List
import scanpy as sc
import time
import os


def compute_score():
    """
    CLI for scoring cell, e.g.,
    TODO: decide whether to move compute_score.py here
    scdrs score --h5ad-file <h5ad_file> ...
    """
    pass


def munge_gs(
    out: str,
    pval_file: str = None,
    zscore_file: str = None,
    weight: str = "zscore",
    fdr: float = None,
    fwer: float = None,
    n_min: int = 100,
    n_max: int = 1000,
):
    """
    CLI for making gene set, convert a MAGMA result-like file to a gene set.
    
    <src_file> is a space-delimited file with the following formats:
    - The first column should corresponds to gene names
    - For the one or more columns to follow, the header should be the disease name,
        and the values should be the gene-level p-values.

    For example, <src_file> looks like

        GENE    BMI    HEIGHT
        OR4F5   0.001  0.01
        DAZ3    0.01   0.001
        ...
    
    This function make the gene weights with the following steps.
    1. Read result, which is assumed to  e.g., MAGMA result file
    2. Thresholding the number of genes using FDR or FWER
    3. Then cap them between `n_min` and `n_max`
    4. Write gene set to `out`

    Examples
    --------
    scdrs make-gs \
        --pval-file <pval_file> \
        --out <out> \
        --weight <weight> \
        --fdr <fdr> \
        --fwer <fwer> \
        --n-min <n_min> \
        --n-max <n_max>
    """
    # either pval_file or zscore_file should be provided
    assert (pval_file is None) != (
        zscore_file is None
    ), "Either `pval_file` or `zscore_file` should be provided"
    if zscore_file is not None:
        # convert z-score to p-values
        df_zscore = pd.read_csv(zscore_file, delim_whitespace=True)
        df_pval = df_zscore.copy()
        for col in df_pval.columns[1:]:
            df_pval[col] = scdrs.util.zsc2pval(df_zscore[col])
    else:
        df_pval = pd.read_csv(pval_file, delim_whitespace=True)

    gene_col = df_pval.columns[0]
    trait_list = df_pval.columns[1:].values

    dict_gene_weights: Dict[str, List] = {
        "TRAIT": [],
        "GENESET": [],
    }
    for trait in trait_list:
        # some p-value can be NaN
        df_trait_pval = df_pval[[gene_col, trait]].copy().dropna(axis=0)

        assert np.all(
            (0 <= df_trait_pval[trait].values) & (df_trait_pval[trait].values <= 1)
        ), f"{trait}'s p-value are not between 0 and 1"

        # Thresholding the number of genes using FDR or FWER (if specified)
        #   and cap them between `n_min` and `n_max`
        assert (fdr is None) or (
            fwer is None
        ), f"`fdr` and `fwer` can not be both specified"
        if fwer is not None:
            n_gene = (
                multipletests(df_trait_pval[trait].values, method="bonferroni")[1]
                < fwer
            )
        elif fdr is not None:
            n_gene = (
                multipletests(df_trait_pval[trait].values, method="fdr_bh")[1] < fdr
            )
        else:
            # if none of them is specified, just use the n_max
            n_gene = n_max

        # 4. cap them between `n_min` and `n_max`
        n_gene = np.minimum(n_gene, n_max)
        n_gene = np.maximum(n_gene, n_min)

        # use the `n_gene` with smallest p-value
        df_trait_pval = (
            df_trait_pval.sort_values(trait).iloc[:n_gene].reset_index(drop=True)
        )
        gene_list = df_trait_pval[gene_col].values
        gene_pvals = df_trait_pval[trait].values
        gene_pvals += 1e-16  # to avoid zero p-value
        if weight == "zscore":
            gene_weights = scdrs.util.pval2zsc(gene_pvals)
        elif weight == "uniform":
            gene_weights = np.ones(len(gene_list))
        else:
            raise ValueError(f"Unknown gene weight option {weight}")

        dict_gene_weights["TRAIT"].append(trait)
        dict_gene_weights["GENESET"].append(
            ",".join([f"{g}:{w:.5g}" for g, w in zip(gene_list, gene_weights)])
        )
    df_gs = pd.DataFrame(dict_gene_weights)
    df_gs.to_csv(out, sep="\t", index=False)


def perform_downstream(
    h5ad_file: str,
    score_file: str,
    out_folder: str,
    group_analysis: str = None,
    corr_analysis: str = None,
    gene_analysis: str = None,
    filter_data: bool = False,
    raw_count: bool = True,
):
    """
    CLI for group-level analysis, e.g.,

    scdrs group-analysis --h5ad-file <h5ad_file> ...

    Parameters
    ----------
    h5ad_file: str
        Path to the h5ad file
    score_file: str
        Path to the score file
    out_folder: str
        Path to the output folder
    group_list: str
        Comma-seperated column names for variables representing groups
        (e.g., cell types or tissues)
    """
    # check arguments
    assert (
        (group_analysis is not None)
        + (corr_analysis is not None)
        + (gene_analysis is not None)
    ) == 1, (
        "only one of `group_analysis`, `corr_analysis`, `gene_analyis` can be specified"
    )
    adata = scdrs.util.load_h5ad(
        h5ad_file=h5ad_file, filter_data=filter_data, raw_count=raw_count
    )
    dict_df_score = scdrs.util.load_drs_score(score_file)

    # branch into different analysis
    if group_analysis is not None:
        if isinstance(group_analysis, str):
            group_cols = group_analysis.split(",")
        elif isinstance(group_analysis, tuple):
            group_cols = [g for g in group_analysis]
        else:
            raise ValueError("group_analysis should be a string or a tuple of strings")
        for trait in dict_df_score:
            dict_df_res = scdrs.util.downstream_group_analysis(
                adata=adata, df_drs=dict_df_score[trait], group_cols=group_cols
            )
            for group_col in group_cols:
                dict_df_res[group_col].to_csv(
                    os.path.join(
                        out_folder,
                        f"{trait}.scdrs_ct.{group_col.replace(' ', '_')}",
                    ),
                    sep="\t",
                    index=True,
                )

    elif corr_analysis is not None:
        if isinstance(corr_analysis, str):
            var_list = corr_analysis.split(",")
        elif isinstance(corr_analysis, tuple):
            var_list = [v for v in corr_analysis]
        else:
            raise ValueError("corr_analysis should be a string or a tuple of strings")
        for trait in dict_df_score:
            df_res = scdrs.util.downstream_corr_analysis(
                adata=adata, df_drs=dict_df_score[trait], var_cols=var_list
            )
            df_res.to_csv(
                os.path.join(out_folder, f"{trait}.scdrs_var"), sep="\t", index=True
            )
    elif gene_analysis is not None:
        for trait in dict_df_score:
            df_res = scdrs.util.downstream_gene_analysis(
                adata=adata, df_drs=dict_df_score[trait]
            )
            # save results
            df_res.to_csv(
                os.path.join(out_folder, f"{trait}.scdrs_gene"), sep="\t", index=True
            )
    else:
        raise ValueError("No analysis specified")


if __name__ == "__main__":
    fire.Fire()